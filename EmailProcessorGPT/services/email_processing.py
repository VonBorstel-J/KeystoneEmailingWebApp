import logging
import os
import json
import openai
from dotenv import load_dotenv
from database.mongodb_setup import get_db
from .data_masking import mask_sensitive_data

# Setup the logging to help in debugging and tracking the flow of the application.
# This configuration ensures that timestamps and log levels are included in log messages.
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Load environment variables from a .env file for better security and flexibility.
# This approach keeps sensitive information like API keys out of the source code.
load_dotenv()
openai.api_key = os.getenv('OPENAI_API_KEY')

# Load the master template for structured data extraction from a JSON file.
# This template is used to guide the extraction of structured data from summaries provided by GPT-3,
# ensuring consistency across the data processing pipeline.
with open(os.path.join(os.getcwd(), 'static', 'master_template.json'), 'r') as f:
    MASTER_TEMPLATE = json.load(f)

def process_email(raw_email):
    """
    Coordinates the processing of an email by orchestrating a series of steps:
    1. Parsing the email to extract key components.
    2. Masking sensitive data to protect privacy.
    3. Summarizing the email content using GPT-3 for key insights.
    4. Extracting structured data from the summary in line with the master template.
    5. Generating actionable suggestions or responses based on the structured data.

    Args:
        raw_email (str): The raw content of the email to be processed.

    Returns:
        dict: A dictionary containing the structured data and generated suggestions, or None if an error occurs.
    """
    parsed_email = parse_email(raw_email)
    if not parsed_email:
        logging.error("Failed to parse email.")
        return None
    
    masked_body = mask_sensitive_data(parsed_email['body'])
    summary = summarize_email(masked_body)
    structured_data = extract_structured_data(summary, masked_body)
    suggestions = generate_response(structured_data, masked_body)

    # Insert the processed data into MongoDB for persistence and further analysis.
    # This allows for tracking the processing outcomes and potentially revisiting the data for reevaluation.
    db = get_db()
    db.emails.insert_one({
        'summary': summary,
        'structured_data': structured_data,
        'suggestions': suggestions
    })

    return suggestions

def parse_email(raw_email):
    """
    Parses the raw email to extract and return basic components such as subject, sender, and body.
    This function serves as a placeholder; you'll need to implement detailed parsing logic based on your email format.

    Args:
        raw_email (str): The raw email content as a string.

    Returns:
        dict: A dictionary with keys for 'subject', 'sender', 'body', and 'email_id', containing the extracted data.
    """
    # Placeholder implementation - replace with your specific email parsing logic.
    return {
        'subject': 'Email Subject',
        'sender': 'sender@example.com',
        'body': raw_email,  # Actual implementation should parse the body content from the raw email.
        'email_id': 'unique_id_here'
    }

def summarize_email(email_body):
    """
    Utilizes OpenAI's GPT-3 to generate a summary of the provided email body, focusing on extracting key information.

    Args:
        email_body (str): The body of the email, potentially masked for sensitive data.

    Returns:
        str: A summary of the email as generated by GPT-3, or None if an error occurs.
    """
    try:
        response = openai.Completion.create(
            engine="text-davinci-003",  # Specifies the GPT-3 model variant to use.
            prompt=f"Summarize this email: {email_body}",  # Crafting the prompt is crucial for effective summarization.
            max_tokens=1024,  # Adjust based on the expected length of the summary.
            temperature=0.5  # Controls the creativity of the response. Closer to 0 means more deterministic.
        )
        summary = response.choices[0].text.strip()
        logging.info(f"Email Summary: {summary}")
        return summary
    except Exception as e:
        logging.error(f"Error summarizing email: {e}")
        return None

def extract_structured_data(summary, email_body):
    """
    Extracts structured data from the email summary using GPT-3, based on the predefined master template.

    Args:
        summary (str): The GPT-3 generated summary of the email.
        email_body (str): The original or masked email body, used for additional context if necessary.

    Returns:
        dict: Structured data extracted from the summary, or None if an error occurs.
    """
    try:
        # The prompt encourages GPT-3 to structure the extracted information according to the master template.
        prompt = f"Based on this summary: '{summary}', extract key information using the provided master template."
        response = openai.Completion.create(
            engine="text-davinci-003",
            prompt=prompt,
            max_tokens=1024,
            temperature=0.5,
        )
        structured_data = json.loads(response.choices[0].text.strip())
        logging.info(f"Structured Data: {structured_data}")
        return structured_data
    except Exception as e:
        logging.error(f"Error extracting structured data: {e}")
        return None

def generate_response(structured_data, email_body):
    """
    Generates a draft response or actionable suggestions based on structured data and the original email body,
    leveraging GPT-3's capabilities for contextual and relevant outputs.

    Args:
        structured_data (dict): The structured information extracted from the email summary.
        email_body (str): The email body, providing context for the response generation.

    Returns:
        str: Generated suggestions or draft response, or None if an error occurs.
    """
    try:
        # This prompt directs GPT-3 to use the structured data for generating practical and context-aware suggestions.
        prompt = f"Generate a draft response or suggestions for next steps based on the structured data: {json.dumps(structured_data, indent=2)}"
        response = openai.Completion.create(
            engine="text-davinci-003",
            prompt=prompt,
            max_tokens=1024,
            temperature=0.7,
        )
        suggestions = response.choices[0].text.strip()
        logging.info(f"Suggestions/Response: {suggestions}")
        return suggestions
    except Exception as e:
        logging.error(f"Error generating suggestions: {e}")
        return None